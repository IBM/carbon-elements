/**
 * Copyright IBM Corp. 2018, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

const { reporter } = require('@carbon/cli-reporter');
const fs = require('fs-extra');
const path = require('path');
const prettier = require('prettier');
const { colors, tokens } = require('../lib');

const SCSS_DIR = path.resolve(__dirname, '../scss');
const SCSS_ENTRYPOINT = path.join(SCSS_DIR, 'colors.scss');
const TOKEN_ENTRYPOINT = path.join(SCSS_DIR, 'tokens.scss');
const GENERATED_COMMENT = `// Code generated by @carbon/colors. DO NOT EDIT.`;
const PREFIX = 'ibm';
const prettierOptions = {
  parser: 'scss',
  printWidth: 80,
  singleQuote: true,
};

async function build() {
  reporter.info('Building scss files for colors and tokens...');

  reporter.info('Cleaning up build directory...');
  await fs.remove(SCSS_DIR);

  reporter.info('Building scss file for colors...');
  const colorsByValue = {};
  const colorsArray = [];
  const uniqueColors = [];
  let colorMap = '';

  const colorsSource = Object.keys(colors).reduce((acc, key) => {
    const parts = getPartsFromKey(key);
    const value = colors[key];
    // We're working in a color without a grade
    if (parts.length === 1) {
      const variable = `$${PREFIX}-colors__${key}`;
      colorsByValue[value] = variable;
      return acc + '\n' + `${variable}: ${value};`;
    }

    const name = parts.slice(0, -1).join('-');
    const grade = parts[parts.length - 1];
    const variable = `$${PREFIX}-colors__${name}--${grade}`;
    colorsByValue[value] = variable;

    // Collect color names and formatted scss color variables with grades.
    colorsArray.push({
      name,
      grade: `${grade}: ${variable}`,
    });

    if (!uniqueColors.includes(name)) {
      uniqueColors.push(name);
    }

    return acc + '\n' + `${variable}: ${value};`;
  }, '');

  // Create a color map entry for each unique color.
  uniqueColors.forEach(color => {
    const colorEntry = colorsArray
      .filter(entry => entry.name === color)
      .map(entry => entry.grade);

    // Convert array entry to string & format it.
    colorMap += `'${color}': (` + colorEntry.join(',') + '),';
  });

  // Format the entire color map.
  const formattedColorMap = `$${PREFIX}-colors-map: (` + colorMap + `)`;

  await fs.ensureDir(SCSS_DIR);
  await fs.writeFile(
    SCSS_ENTRYPOINT,
    prettier.format(
      GENERATED_COMMENT + '\n' + (colorsSource + '\n\n' + formattedColorMap),
      prettierOptions
    )
  );

  reporter.info('Building scss file for tokens...');
  const tokenSource = Object.keys(tokens).reduce((acc, key) => {
    const parts = getPartsFromKey(key);
    const name = parts.join('-');
    const value = tokens[key];

    if (colorsByValue[value]) {
      return acc + '\n' + `$${name}: ${colorsByValue[value]};`;
    }

    return acc + '\n' + `$${name}: ${value};`;
  }, '');

  const COLOR_IMPORT = `@import 'colors';`;

  await fs.writeFile(
    TOKEN_ENTRYPOINT,
    prettier.format(
      GENERATED_COMMENT + '\n' + COLOR_IMPORT + '\n' + tokenSource,
      prettierOptions
    )
  );

  reporter.success('Done! ðŸŽ‰');
}

function getPartsFromKey(key) {
  const parts = [];
  let currentPart = '';
  let prevCharacter = null;

  for (let i = 0; i < key.length; i++) {
    const character = key[i];

    // We hit this branch when we start processing the number at the end of the
    // key. For example, the `1` or `0`s in `warmGray100`.
    if (!isNaN(character)) {
      // If the previous number wasn't a character, we can push the current part
      // and start working on the number part
      if (isNaN(prevCharacter)) {
        parts.push(currentPart);
        currentPart = '';
      }

      currentPart += character;
      prevCharacter = character;
      continue;
    }

    // We hit this branch when we have a name that is camelCase. For example,
    // the `G` in `warmGray`
    if (character === character.toUpperCase()) {
      if (prevCharacter !== prevCharacter.toUpperCase()) {
        parts.push(currentPart);
        currentPart = character.toLowerCase();
      } else {
        currentPart += character.toLowerCase();
      }
      prevCharacter = character;
      continue;
    }

    // Default case where we are already working on the current part. This
    // collects letters and puts them on the current string.
    currentPart += character;
    prevCharacter = character;
  }
  parts.push(currentPart);

  return parts;
}

module.exports = build;
